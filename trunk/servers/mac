#!/usr/bin/python2.5
# E-Mac-Speak
# Emacspeak on Mac.
# Initial contributer: David Tseng

import sys
import re

from Foundation import *
from PyObjCTools import AppHelper
from AppKit import NSObject
from AppKit import NSSpeechSynthesizer

# Globals.
# amount to increase pitch of capital letters.  This may need tweaking. 
capsPitchIncrease = 8

# Debug level
# 0 means no debug output is written 10 is maximum output
debugLevel = 10

# Should debug output also be written to STDOUT?
debugToSTDOUT = 0

# A debug file to place sample tts text sent by emacspeak.
DEBUGFILE = open("/tmp/speech.log","w")

# Possible levels of punctuation (none, some, all).
punctuationLevel = "none"

# used to pronounce punctuation chars
punctuationMap= {'$':'dollar',
                 '#':'pound', 
                 '-':'dash',
                  '"':'quote',
                   '(':'leftParen',
                    ')':'rightParen',
                 '*':'star',
                 ';':'semi',
                 ':':'colon',
                 '<':'less than',
                 '>':'greater than',
                 '\n':'new line'}


# map voice short names to apple class names.
voiceMap= {'alex':'com.apple.speech.synthesis.voice.Alex',
           'victoria':'com.apple.speech.synthesis.voice.Victoria',
           'vicki':'com.apple.speech.synthesis.voice.Vicki',
           'ralf':'com.apple.speech.synthesis.voice.Ralph',
           'kathy':'com.apple.speech.synthesis.voice.Kathy',
           'junior':'com.apple.speech.synthesis.voice.Junior',
           'fred':'com.apple.speech.synthesis.voice.Fred',
           'bruce':'com.apple.speech.synthesis.voice.Bruce'}

# A queue of either text or audio filenames waiting to be dispatched to NSSpeechSynthesizer.
speechQueue = []

"""
  Helper for consuming callbacks from NSSpeechSynthesizer.
"""
class SpeechSynthesizerDelegate(NSObject):
  def speechSynthesizer_didFinishSpeaking_(self, synthesizer, success):
    processSpeechQueue()

speechSynthesizer = NSSpeechSynthesizer.alloc().init()
delegate_ = SpeechSynthesizerDelegate.alloc().init();
speechSynthesizer.setRate_(500)
speechSynthesizer.setDelegate_(delegate_)

"""
  An object which observes stdin.
  This class largely contains basic i/o for reading from stdin using
  NSNotificationCenter..
"""
class FileObserver(NSObject):
    def initWithFileDescriptor_readCallback_errorCallback_(self,
            fileDescriptor, readCallback, errorCallback):
        self = self.init()
        self.readCallback = readCallback
        self.errorCallback = errorCallback
        self.fileHandle = NSFileHandle.alloc().initWithFileDescriptor_(
            fileDescriptor)
        self.nc = NSNotificationCenter.defaultCenter()
        self.protocolHandler = ProtocolHandler()
        self.nc.addObserver_selector_name_object_(
            self,
            'fileHandleReadCompleted:',
            NSFileHandleReadCompletionNotification,
            self.fileHandle)
        self.fileHandle.readInBackgroundAndNotify()
        return self

    def fileHandleReadCompleted_(self, aNotification):
        ui = aNotification.userInfo()
        newData = ui.objectForKey_(NSFileHandleNotificationDataItem)
        if newData is None:
            if self.errorCallback is not None:
                self.errorCallback(self, ui.objectForKey_(NSFileHandleError))
            self.close()
        else:
            self.fileHandle.readInBackgroundAndNotify()
            if self.readCallback is not None:
                self.readCallback(self, str(newData))

    def close(self):
        self.nc.removeObserver_(self)
        if self.fileHandle is not None:
            self.fileHandle.closeFile()
            self.fileHandle = None
        # break cycles in case these functions are closed over
        # an instance of us
        self.readCallback = None
        self.errorCallback = None

    def __del__(self):
        # Without this, if a notification fires after we are GC'ed
        # then the app will crash because NSNotificationCenter
        # doesn't retain observers.  In this example, it doesn't
        # matter, but it's worth pointing out.
        self.close()

# This is conceptually the main entry point of the server.
def gotLine(observer, aLine):
    if aLine:
        writeDebugLog(2, "gotline: " + aLine.rstrip() +  "\nend\n")
        observer.protocolHandler.dispatchRawTtsMessage(aLine.rstrip())
    else:
        AppHelper.stopEventLoop()

def gotError(observer, err):
    print "error:", err
    AppHelper.stopEventLoop()

def writeDebugLog(level, output):
    # do nothing if debug is off
    if debugLevel == 0:
        return

    if level <= debugLevel:
        if output:
            DEBUGFILE.write(output)
            # Write debug messages to STDOUT if requested as well
            if debugToSTDOUT:
                print output + "\n"
        DEBUGFILE.flush()


# Object that implements the Emacspeak TTS protocol.
# TODO: finish refactoring blocks from global dispatchTtsCommand.
class ProtocolHandler:
  def __init__(self):
    # Maps a protocol id to a handler function.
    # TODO: Add all implemented messages here.
    self.protocolIdToHandlerMap = { 'd':self.handleDispatch,
                                    'l':self.handleLetter,
                                    'q':self.handleQueue,
                                    's':self.handleStopSpeaking,
                                    'tts_say':self.handleTtsSay,
                                    'tts_set_punctuations':self.handleTtsSetPunctuations }
    # Used to extract protocol id and args from a raw message.
    self.protocolRePattern = (
      r"((?P<blockId>[a-z\-]*) {(?P<blockArg>[\s\S]*))|((?P<spaceId>[a-z_]*) (?P<spaceArg>[\s\S]*))|(?P<id>[a-z_]*)")
    # Used to detect multiple dispatches during processing of one chunk set.
    self.isProcessing = False
    # Hack to get multiline q's working.
    self.queueContinuationValue = ""
    self.isQueueContinuation = False

  # Protocol Handlers.
  def handleDispatch(self, args):
    # sometimes we receive multiple dispatches within the same chunks set.
    if not self.isProcessing:
      processSpeechQueue()
      self.isProcessing = True

  def handleLetter(self, args):
    output = args.strip(" }")

    # Bart FIXME: setting the output to literal has undesired effects when phonemic pronounciation matches so have gone with initial empty strings for prefix and suffix but kept the below two lines just in case we change our minds.
    #prefix = "[[char LTRL]]"
    #suffix = "[[char NORM]]"
    prefix = ""
    suffix = ""

    writeDebugLog(4, "Letter: " + output + "\n")
    self.handleStopSpeaking(None)

    # punctuation processing
    if output in punctuationMap:
      output = punctuationMap[output]
      writeDebugLog(8, "punctuationMap match, output now: " + output + "\n")  

    # Check if this is a capital
    if re.match(r"^[A-Z]+$", output):
      prefix = prefix + " [[pbas +" + str(capsPitchIncrease) + "]]"
      suffix = "[[pbas -" + str(capsPitchIncrease) + "]] " + suffix

    # add prefix and suffix to output 
    output = prefix + " " + output + " " + suffix
    writeDebugLog(4, "about to speak letter: " + output + "\n")
    # Send directly to TTS to avoid any line processing.
    speechSynthesizer.startSpeakingString_(output)

  def handleQueue(self, args):
    if re.search(r"^(.*)(\[\[voice [a-z]*\]\])(.*)$", args):
      queueTextWithVoiceCommands(args)
    else:
      self.queueContinuationValue = self.queueContinuationValue + args
      if args.endswith('}'):
        speechQueue.append(("text", self.queueContinuationValue))
 	self.queueContinuationValue = ""
	self.isQueueContinuation = False
      else:
        self.isQueueContinuation = True

  def handleStopSpeaking(self, args):
    speechSynthesizer.stopSpeaking()
    del(speechQueue[:])

  def handleTtsSay(self, args):
    speechSynthesizer.startSpeakingString_(args)
  def handleTtsSetPunctuations(self, args):
    global punctuationLevel
    punctuationLevel = args
    writeDebugLog(4, "Setting punctuation level: " +  punctuationLevel)

  def dispatchRawTtsMessage(self, message):
    self.isProcessing = False
    writeDebugLog(4, "dispatchRawTtsMessage")
    chunks = message.split('\n')
    for chunk in chunks:
      writeDebugLog(4, "\nchunk: " + chunk + "\nend\n")                      
      if not chunk:
        continue

      if self.isQueueContinuation:
        self.handleQueue(chunk)
        continue

      # Extract protocol id and protocol args.
      matcher = re.match(self.protocolRePattern, chunk)

      # Message validation.
      if not matcher or ( 
        len(matcher.groups()) != 7):
        writeDebugLog(4, "Unable to parse pattern " + chunk)
        continue

      # Note the presence of three types of protocol messages:
      # 1. containing only id.
      # 2. containing id and {...} block.
      # 3. containing id and space delimited args.
      id = matcher.group('id')
      blockId = matcher.group('blockId')
      blockArg = matcher.group('blockArg')
      spaceId = matcher.group('spaceId')
      spaceArg = matcher.group('spaceArg')

      # Send off to the handler.
      if id and self.protocolIdToHandlerMap.has_key(id):
        self.protocolIdToHandlerMap[id](None)
      elif (
        blockId and
        self.protocolIdToHandlerMap.has_key(blockId)):
        self.protocolIdToHandlerMap[blockId](blockArg)
      elif (
        spaceId and
        spaceArg and self.protocolIdToHandlerMap.has_key(spaceId)):
        self.protocolIdToHandlerMap[spaceId](spaceArg)
      else:
        print "unable to parse"
        writeDebugLog(
          4, "Error! unsupported message id:%s, blockId:%s, blockArg:%s, spaceId:%s, spaceArg:%s" % (
          id, blockId, blockArg, spaceId, spaceArg))

        #TODO:  support protocol commands.
        #if chunk == "version":
        #speak tts version

        #if chunk == "tts_pause":
        #if chunk == "tts_resume":
        #if chunk.startswith"a "):
        #queue the filename for playing.
        #if chunk.startswith("t "):
        #t freq length - play tone at freq and for length time (hz/ms).
        #if chunk.startswith("sh "):
        #silence for ms.
        #if chunk == "tts_reset":
        #if chunk.startswith("tts_set_speech_rate ":
#tts_set_character_scale factor (rate for spekaking chars)
#tts_split_caps flag (speak camal case words).
#tts_capitalize flag (beep on caps)
#tts_allcaps_beep flag (beep)


# This takes a string with imbedded voice changes and splits it up and queues individual text events with voice changes inbetween.
def queueTextWithVoiceCommands(text):
    writeDebugLog(4, "process text with voice commands")
    while text:
        # try cleaning out the extra spaces
        text = text.strip("{} ")
        matcher = re.match(r"^(?P<first>.*?)\[\[voice (?P<voice>[a-z]*)\]\](?P<rest>.*)$", text)
        if not matcher:
            writeDebugLog(8, "no match in string " + text + "\n")
            break
        first = matcher.group('first')
        voice = matcher.group('voice')
        rest = matcher.group('rest')
        if first:
            speechQueue.append(("text", first))
        speechQueue.append(("voice", voice))
        writeDebugLog(8, "first: " + first + "\nvoice " + voice + "\nrest " + rest)
        text = rest
    if text:
        writeDebugLog(8, "queueing final chunk " + text)
        speechQueue.append(("text", text))


# Processes speech objects.
# TODO: encapsulate speech objects as a class.  Currently, just an array.
#  format is:
#  { type, value }
#  this really should just be a proper class.
def processSpeechQueue():
    if (len(speechQueue) > 0):
        item = speechQueue.pop(0)
        #Text
        if item[0] == "text":
            #Basic processing.  TODO: refactor.
            output = item[1].strip(" {}")
            if output:
                print punctuationLevel
                output = ProcessSpecialCharacters(output)
                speechSynthesizer.startSpeakingString_(output)
                writeDebugLog(2, "\nsay: " + item[1] + "\nend\n")
            else:
                processSpeechQueue()
        elif item[0] == "voice":
            writeDebugLog(4, "Voice change")
            voice = item[1]
            if voice in voiceMap:
                speechSynthesizer.setVoice_(voiceMap[voice])
                writeDebugLog(6, "set voice to " + voiceMap[voice])  
                processSpeechQueue()

def ProcessSpecialCharacters(wordList):
  expansion = ""
  for i in range(len(wordList)):
    if wordList[i] in punctuationMap:
      expansion += ' ' + (punctuationMap[wordList[i]]) + ' '
    else:
      expansion += (wordList[i])
  return expansion

def main():
    observer = FileObserver.alloc().initWithFileDescriptor_readCallback_errorCallback_(
        sys.stdin.fileno(), gotLine, gotError)
    try:
        AppHelper.runConsoleEventLoop()
    except KeyboardInterrupt:
        writeDebugLog(2, "\nKeyboard interrupt")

if __name__ == '__main__':
    main()
