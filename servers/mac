#!/usr/bin/python2.5
# E-Mac-Speak
# Emacspeak on Mac.
# Initial contributer: David Tseng

import sys
import re

from Foundation import *
from PyObjCTools import AppHelper
from AppKit import NSObject
from AppKit import NSSpeechSynthesizer

# Globals.
# amount to increase pitch of capital letters.  This may need tweaking. 
capsPitchIncrease = 8

# Debug level
# 0 means no debug output is written 10 is maximum output
debugLevel = 10

# Should debug output also be written to STDOUT?
debugToSTDOUT = 0

# A debug file to place sample tts text sent by emacspeak.
DEBUGFILE = open("/tmp/speech.log","w")

# Possible levels of punctuation (none, some, all).
punctuationLevel = "none"

# used to pronounce punctuation chars
punctuationMap= {'$':'dollar',
                 '#':'pound', 
                 '-':'dash',
                  '"':'quote',
                   '(':'leftParen',
                    ')':'rightParen',
                 '<':'less than',
                 '>':'greater than',
                 '\n':'new line'}


# map voice short names to apple class names.
voiceMap= {'alex':'com.apple.speech.synthesis.voice.Alex',
           'victoria':'com.apple.speech.synthesis.voice.Victoria',
           'vicki':'com.apple.speech.synthesis.voice.Vicki',
           'ralf':'com.apple.speech.synthesis.voice.Ralph',
           'kathy':'com.apple.speech.synthesis.voice.Kathy',
           'junior':'com.apple.speech.synthesis.voice.Junior',
           'fred':'com.apple.speech.synthesis.voice.Fred',
           'bruce':'com.apple.speech.synthesis.voice.Bruce'}

# A queue of either text or audio filenames waiting to be dispatched to NSSpeechSynthesizer.
speechQueue = []

"""
  Helper for consuming callbacks from NSSpeechSynthesizer.
"""
class SpeechSynthesizerDelegate(NSObject):
  def speechSynthesizer_didFinishSpeaking_(self, synthesizer, success):
    processSpeechQueue()

speechSynthesizer = NSSpeechSynthesizer.alloc().init()
delegate_ = SpeechSynthesizerDelegate.alloc().init();
speechSynthesizer.setRate_(500)
speechSynthesizer.setDelegate_(delegate_)

"""
  An object which observes stdin.
  This class largely contains basic i/o for reading from stdin using
  NSNotificationCenter..
"""
class FileObserver(NSObject):
    def initWithFileDescriptor_readCallback_errorCallback_(self,
            fileDescriptor, readCallback, errorCallback):
        self = self.init()
        self.reFilter = re.compile(r"\{.*?\}")
        self.readCallback = readCallback
        self.errorCallback = errorCallback
        self.fileHandle = NSFileHandle.alloc().initWithFileDescriptor_(
            fileDescriptor)
        self.nc = NSNotificationCenter.defaultCenter()
        self.protocolHandler = ProtocolHandler()
        self.nc.addObserver_selector_name_object_(
            self,
            'fileHandleReadCompleted:',
            NSFileHandleReadCompletionNotification,
            self.fileHandle)
        self.fileHandle.readInBackgroundAndNotify()
        return self

    def fileHandleReadCompleted_(self, aNotification):
        ui = aNotification.userInfo()
        newData = ui.objectForKey_(NSFileHandleNotificationDataItem)
        if newData is None:
            if self.errorCallback is not None:
                self.errorCallback(self, ui.objectForKey_(NSFileHandleError))
            self.close()
        else:
            self.fileHandle.readInBackgroundAndNotify()
            if self.readCallback is not None:
                self.readCallback(self, str(newData))

    def close(self):
        self.nc.removeObserver_(self)
        if self.fileHandle is not None:
            self.fileHandle.closeFile()
            self.fileHandle = None
        # break cycles in case these functions are closed over
        # an instance of us
        self.readCallback = None
        self.errorCallback = None

    def __del__(self):
        # Without this, if a notification fires after we are GC'ed
        # then the app will crash because NSNotificationCenter
        # doesn't retain observers.  In this example, it doesn't
        # matter, but it's worth pointing out.
        self.close()

# This is conceptually the main entry point of the server.
def gotLine(observer, aLine):
    if aLine:
        writeDebugLog(2, "gotline: " + aLine.rstrip() +  "\nend\n")
        # TODO: uncomment once finish transition.
        #observer.protocolHandler.dispatchRawTtsMessage(aLine.rstrip())
        dispatchTtsCommand(aLine.rstrip())
    else:
        print ""
        AppHelper.stopEventLoop()

def gotError(observer, err):
    print "error:", err
    AppHelper.stopEventLoop()

def writeDebugLog(level, output):
    # do nothing if debug is off
    if debugLevel == 0:
        return

    if level <= debugLevel:
        if output:
            DEBUGFILE.write(output)
            # Write debug messages to STDOUT if requested as well
            if debugToSTDOUT:
                print output + "\n"
        DEBUGFILE.flush()


# Object that implements the Emacspeak TTS protocol.
# TODO: finish refactoring blocks from global dispatchTtsCommand.
class ProtocolHandler:
  def __init__(self):
    # Maps a protocol id to a handler function.
    # TODO: Add all implemented messages here.
    self.protocolIdToHandlerMap = { 's':self.handleStopSpeaking }
    # Used to extract protocol id and args from a raw message.
    self.protocolRePattern = (
      r"((?P<id_args>[a-z\-]*) {(?P<args>[\s\S]*))|(?P<id>[a-z]*)")

  # Protocol Handlers.
  def handleStopSpeaking(self, args):
    speechSynthesizer.stopSpeaking()
    del(speechQueue[:])

  def dispatchRawTtsMessage(self, message):
    writeDebugLog(4, "dispatchRawTtsMessage")
    chunks = message.split('\n')
    for chunk in chunks:
      writeDebugLog(4, "\nchunk: " + chunk + "\nend\n")                      
      if not chunk:
        continue

      # Extract protocol id and protocol args.
      matcher = re.match(self.protocolRePattern, chunk)

      # Message validation.
      if not matcher or ( 
        len(matcher.groups()) != 4):
        writeDebugLog(4, "Unable to parse pattern " + chunk)
        continue

      # Note the presence of two types of protocol messages:
      # 1.  Non-empty id.
      # 2. Non-empty id_args and args.
      id = matcher.group('id')
      id_args = matcher.group('id_args')
      args = matcher.group('args')

      # Send off to the handler.
      if id and self.protocolIdToHandlerMap.has_key(id):
        self.protocolIdToHandlerMap[id](args)
      elif (
        id_args and args and self.protocolIdToHandlerMap.has_key(id_args)):
        self.protocolIdToHandlerMap[id](args)
      else:
        writeDebugLog(
          4, "Error! unsupported message id:%s, id_args:%s, args:%s" % (
          id, id_args, args))


# Handles TTS protocol messages sent from emacspeak.
# TODO: Remove once existing code refactored.
def dispatchTtsCommand(input):
    writeDebugLog(4, "dispatchTtsCommand")
    is_processing = False
    chunks = input.split('\n')
    for chunk in chunks:
        writeDebugLog(4, "\nchunk: " + chunk + "\nend")
        if not chunk:
            continue

        # Extract protocol id and protocol args.
        """matcher = re.match(protocolRePattern, chunk)
        if not matcher or (
          len(matcher.groups()) != 1):
                                      continue
"""
        if chunk =="d":
        # sometimes we receive multiple dispatches within the same chunks set.
            if not is_processing:
                processSpeechQueue()
                is_processing = True

        # Letter processing, this is for speaking an individual letter 
        #TODO: investigate latency.
        if chunk.startswith("l "):
            output = chunk.replace("l ", "", 1).strip("{} ")

            # Bart FIXME: setting the output to literal has undesired effects when phonemic pronounciation matches so have gone with initial empty strings for prefix and suffix but kept the below two lines just in case we change our minds.
            #prefix = "[[char LTRL]]"
            #suffix = "[[char NORM]]"
            prefix = ""
            suffix = ""

            writeDebugLog(4, "Letter: " + output + "\n")
            dispatchTtsCommand('s')

            # punctuation processing
            if output in punctuationMap:
                output = punctuationMap[output]
                writeDebugLog(8, "punctuationMap match, output now: " + output + "\n")  

            # Check if this is a capital
            if re.match(r"^[A-Z]+$", output):
                prefix = prefix + " [[pbas +" + str(capsPitchIncrease) + "]]"
                suffix = "[[pbas -" + str(capsPitchIncrease) + "]] " + suffix

            # add prefix and suffix to output 
            output = prefix + " " + output + " " + suffix
            writeDebugLog(4, "about to speak letter: " + output + "\n")
            # Send directly to TTS to avoid any line processing.
            speechSynthesizer.startSpeakingString_(output)
            

        if chunk.startswith("q "):
          chunk = chunk.replace("q {", "", 1)
          if chunk:
            if re.search(r"^(.*)(\[\[voice [a-z]*\]\])(.*)$", chunk):
                queueTextWithVoiceCommands(chunk)
            else:
                speechQueue.append(("text", chunk))


        if chunk == "s":
            speechSynthesizer.stopSpeaking()
            del(speechQueue[:])

        if chunk.startswith("tts_say"):
            speechSynthesizer.startSpeakingString_(chunk.replace("tts_say ", "", 1).strip("{}"))

        #TODO:  support protocol commands.
        #if chunk == "version":
        #speak tts version

        #if chunk == "tts_pause":
        #if chunk == "tts_resume":
        #if chunk.startswith"a "):
        #queue the filename for playing.
        #if chunk.startswith("t "):
        #t freq length - play tone at freq and for length time (hz/ms).
        #if chunk.startswith("sh "):
        #silence for ms.

        #setters
        if chunk.startswith("tts_set_punctuations "):
          global punctuationLevel
	  punctuationLevel = chunk.replace("tts_set_punctuations ", "", 1)
          writeDebugLog(4, "Setting punctuation level: " +  punctuationLevel)

        #if chunk == "tts_reset":
        #if chunk.startswith("tts_set_speech_rate ":
#tts_set_character_scale factor (rate for spekaking chars)
#tts_split_caps flag (speak camal case words).
#tts_capitalize flag (beep on caps)
#tts_allcaps_beep flag (beep)


# This takes a string with imbedded voice changes and splits it up and queues individual text events with voice changes inbetween.
def queueTextWithVoiceCommands(text):
    writeDebugLog(4, "process text with voice commands")
    while text:
        # try cleaning out the extra spaces
        text = text.strip("{} ")
        matcher = re.match(r"^(?P<first>.*?)\[\[voice (?P<voice>[a-z]*)\]\](?P<rest>.*)$", text)
        if not matcher:
            writeDebugLog(8, "no match in string " + text + "\n")
            break
        first = matcher.group('first')
        voice = matcher.group('voice')
        rest = matcher.group('rest')
        if first:
            speechQueue.append(("text", first))
        speechQueue.append(("voice", voice))
        writeDebugLog(8, "first: " + first + "\nvoice " + voice + "\nrest " + rest)
        text = rest
    if text:
        writeDebugLog(8, "queueing final chunk " + text)
        speechQueue.append(("text", text))


# Processes speech objects.
# TODO: encapsulate speech objects as a class.  Currently, just an array.
#  format is:
#  { type, value }
#  this really should just be a proper class.
def processSpeechQueue():
    if (len(speechQueue) > 0):
        item = speechQueue.pop(0)
        #Text
        if item[0] == "text":
            #Basic processing.  TODO: refactor.
            output = item[1].strip(" {}")
            if output:
                print punctuationLevel
                output = ProcessSpecialCharacters(output)
                speechSynthesizer.startSpeakingString_(output)
            writeDebugLog(2, "\nsay: " + item[1] + "\nend\n")
        elif item[0] == "voice":
            writeDebugLog(4, "Voice change")
            voice = item[1]
            if voice in voiceMap:
                speechSynthesizer.setVoice_(voiceMap[voice])
                writeDebugLog(6, "set voice to " + voiceMap[voice])  
                processSpeechQueue()

def ProcessSpecialCharacters(wordList):
  expansion = ""
  for i in range(len(wordList)):
    if wordList[i] in punctuationMap:
      expansion += ' ' + (punctuationMap[wordList[i]]) + ' '
    else:
      expansion += (wordList[i])
  return expansion

def main():
    observer = FileObserver.alloc().initWithFileDescriptor_readCallback_errorCallback_(
        sys.stdin.fileno(), gotLine, gotError)
    try:
        AppHelper.runConsoleEventLoop()
    except KeyboardInterrupt:
        writeDebugLog(2, "\nKeyboard interrupt")

if __name__ == '__main__':
    main()
