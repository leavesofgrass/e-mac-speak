#!/usr/bin/python2.5
# E-Mac-Speak
# Emacspeak on Mac.
# Initial contributer: David Tseng

import sys
import re

from Foundation import *
from PyObjCTools import AppHelper
from AppKit import NSObject
from AppKit import NSSpeechSynthesizer

# Globals.
# amount to increase pitch of capital letters.  This may need tweaking. 
capsPitchIncrease = 8
# Debug level
# 0 means no debug output is written 10 is maximum output
debugLevel = 10
# Should debug output also be written to STDOUT?
debugToSTDOUT = 0
# A debug file to place sample tts text sent by emacspeak.
DEBUGFILE = open("/tmp/speech.log","w")

# used to pronounce punctuation chars
punctuationMap= {'$':'dollar',
                 '#':'pound', 
                 '-':'dash',
                  '"':'quote',
                   '(':'leftParen',
                    ')':'rightParen',
                 '<':'less than',
                 '>':'greater than',
                 '\n':'new line'}

# Possible levels of punctuation (none, some, all).
punctuationLevel = "none"

# A queue of either text or audio filenames waiting to be dispatched to NSSpeechSynthesizer.
speechQueue = []

"""
  Helper for consuming callbacks from NSSpeechSynthesizer.
"""
class SpeechSynthesizerDelegate(NSObject):
  def speechSynthesizer_didFinishSpeaking_(self, synthesizer, success):
    processSpeechQueue()

speechSynthesizer = NSSpeechSynthesizer.alloc().init()
delegate_ = SpeechSynthesizerDelegate.alloc().init();
speechSynthesizer.setRate_(500)
speechSynthesizer.setDelegate_(delegate_)

"""
  An object which observes stdin.
  This class largely contains basic i/o for reading from stdin using
  NSNotificationCenter..
"""
class FileObserver(NSObject):
    def initWithFileDescriptor_readCallback_errorCallback_(self,
            fileDescriptor, readCallback, errorCallback):
        self = self.init()
        self.reFilter = re.compile(r"\{.*?\}")
        self.readCallback = readCallback
        self.errorCallback = errorCallback
        self.fileHandle = NSFileHandle.alloc().initWithFileDescriptor_(
            fileDescriptor)
        self.nc = NSNotificationCenter.defaultCenter()
        self.nc.addObserver_selector_name_object_(
            self,
            'fileHandleReadCompleted:',
            NSFileHandleReadCompletionNotification,
            self.fileHandle)
        self.fileHandle.readInBackgroundAndNotify()
        return self

    def fileHandleReadCompleted_(self, aNotification):
        ui = aNotification.userInfo()
        newData = ui.objectForKey_(NSFileHandleNotificationDataItem)
        if newData is None:
            if self.errorCallback is not None:
                self.errorCallback(self, ui.objectForKey_(NSFileHandleError))
            self.close()
        else:
            self.fileHandle.readInBackgroundAndNotify()
            if self.readCallback is not None:
                self.readCallback(self, str(newData))

    def close(self):
        self.nc.removeObserver_(self)
        if self.fileHandle is not None:
            self.fileHandle.closeFile()
            self.fileHandle = None
        # break cycles in case these functions are closed over
        # an instance of us
        self.readCallback = None
        self.errorCallback = None

    def __del__(self):
        # Without this, if a notification fires after we are GC'ed
        # then the app will crash because NSNotificationCenter
        # doesn't retain observers.  In this example, it doesn't
        # matter, but it's worth pointing out.
        self.close()

# This is conceptually the main entry point of the server.
def gotLine(observer, aLine):
    if aLine:
        writeDebugLog(2, "gotline: " + aLine.rstrip() +  "\nend\n")
        dispatchTtsCommand(aLine.rstrip())
    else:
        print ""
        AppHelper.stopEventLoop()

def gotError(observer, err):
    print "error:", err
    AppHelper.stopEventLoop()

def writeDebugLog(level, output):
    # do nothing if debug is off
    if debugLevel == 0:
        return

    if level <= debugLevel:
        if output:
            DEBUGFILE.write(output)
            # Write debug messages to STDOUT if requested as well
            if debugToSTDOUT:
                print output + "\n"
        DEBUGFILE.flush()


# Handles TTS protocol messages sent from emacspeak.
def dispatchTtsCommand(input):
    is_processing = False
    chunks = input.split('\n')
    for chunk in chunks:
        writeDebugLog(4, "\nchunk: " + chunk + "\nend\n")
        if not chunk:
            continue

        if chunk =="d":
        # sometimes we receive multiple dispatches within the same chunks set.
            if not is_processing:
                processSpeechQueue()
                is_processing = True

        # Letter processing, this is for speaking an individual letter 
        #TODO: investigate latency.
        if chunk.startswith("l "):
            speechSynthesizer.stopSpeaking()
            output = chunk.replace("l ", "", 1).strip("{} ")

            # Bart FIXME: setting the output to literal has undesired effects when phonemic pronounciation matches so have gone with initial empty strings for prefix and suffix but kept the below two lines just in case we change our minds.
            #prefix = "[[char LTRL]]"
            #suffix = "[[char NORM]]"
            prefix = ""
            suffix = ""

            writeDebugLog(4, "Letter: " + output + "\n")
            dispatchTtsCommand('s')

            # Check if this is a capital
            if re.match(r"^[A-Z]+$", output):
                prefix = prefix + " [[pbas +" + str(capsPitchIncrease) + "]]"
                suffix = "[[pbas -" + str(capsPitchIncrease) + "]] " + suffix

            # add prefix and suffix to output 
            output = prefix + " " + output + " " + suffix
            writeDebugLog(4, "about to speak letter: " + output + "\n")
            speechQueue.append(("text", output))
            dispatchTtsCommand('d')

        if chunk.startswith("q "):
          chunk = chunk.replace("q {", "", 1)
          if chunk:
            speechQueue.append(("text", chunk))


        if chunk == "s":
            speechSynthesizer.stopSpeaking()
            del(speechQueue[:])

        if chunk.startswith("tts_say"):
            speechSynthesizer.startSpeakingString_(chunk.replace("tts_say ", "", 1).strip("{}"))

        #TODO:  support protocol commands.
        #if chunk == "version":
        #speak tts version

        #if chunk == "tts_pause":
        #if chunk == "tts_resume":
        #if chunk.startswith"a "):
        #queue the filename for playing.
        #if chunk.startswith("t "):
        #t freq length - play tone at freq and for length time (hz/ms).
        #if chunk.startswith("sh "):
        #silence for ms.

        #setters
        if chunk.startswith("tts_set_punctuations "):
          global punctuationLevel
	  punctuationLevel = chunk.replace("tts_set_punctuations ", "", 1)
          writeDebugLog(4, "Setting punctuation level: " +  punctuationLevel)

        #if chunk == "tts_reset":
        #if chunk.startswith("tts_set_speech_rate ":
#tts_set_character_scale factor (rate for spekaking chars)
#tts_split_caps flag (speak camal case words).
#tts_capitalize flag (beep on caps)
#tts_allcaps_beep flag (beep)

# Processes speech objects.
# TODO: encapsulate speech objects as a class.  Currently, just an array.
#  format is:
#  { type, value }
#  this really should just be a proper class.
def processSpeechQueue():
    if (len(speechQueue) > 0):
        item = speechQueue.pop(0)
        #Text
        if item[0] == "text":
            #Basic processing.  TODO: refactor.
            output = item[1].strip(" {}")
            if output:
                print punctuationLevel
                output = ProcessSpecialCharacters(output)
                speechSynthesizer.startSpeakingString_(output)
            writeDebugLog(2, "\nsay: " + item[1] + "\nend\n")

def ProcessSpecialCharacters(wordList):
  expansion = ""
  for i in range(len(wordList)):
    if wordList[i] in punctuationMap:
      expansion += ' ' + (punctuationMap[wordList[i]]) + ' '
    else:
      expansion += (wordList[i])
  return expansion

def main():
    observer = FileObserver.alloc().initWithFileDescriptor_readCallback_errorCallback_(
        sys.stdin.fileno(), gotLine, gotError)
    try:
        AppHelper.runConsoleEventLoop()
    except KeyboardInterrupt:
        writeDebugLog(2, "\nKeyboard interrupt")

if __name__ == '__main__':
    main()
